import {
  __require,
  __spreadValues
} from "../chunk-UH52UDT5.mjs";

// src/node/cli.ts
import yargs from "yargs";

// src/node/build.ts
import { join, dirname, isAbsolute, parse, resolve } from "path";
import chalk2 from "chalk";
import fs from "fs-extra";
import { build as viteBuild, resolveConfig } from "vite";
import { renderToString } from "@vue/server-renderer";
import { JSDOM, VirtualConsole } from "jsdom";

// src/node/preload-links.ts
function renderPreloadLinks(document, modules, ssrManifest) {
  const seen = new Set();
  const preloadLinks = [];
  Array.from(modules).forEach((id) => {
    const files = ssrManifest[id] || [];
    files.forEach((file) => {
      if (!preloadLinks.includes(file))
        preloadLinks.push(file);
    });
  });
  if (preloadLinks) {
    preloadLinks.forEach((file) => {
      if (!seen.has(file)) {
        seen.add(file);
        renderPreloadLink(document, file);
      }
    });
  }
}
function renderPreloadLink(document, file) {
  if (file.endsWith(".js")) {
    appendLink(document, {
      rel: "modulepreload",
      crossOrigin: "",
      href: file
    });
  } else if (file.endsWith(".css")) {
    appendLink(document, {
      rel: "stylesheet",
      href: file
    });
  }
}
var createLink = (document) => document.createElement("link");
var setAttrs = (el, attrs) => {
  const keys = Object.keys(attrs);
  for (const key of keys)
    el.setAttribute(key, attrs[key]);
};
function appendLink(document, attrs) {
  const exits = document.head.querySelector(`link[href='${attrs.file}']`);
  if (exits)
    return;
  const link = createLink(document);
  setAttrs(link, attrs);
  document.head.appendChild(link);
}

// src/node/utils.ts
import chalk from "chalk";
function buildLog(text, count) {
  console.log(`
${chalk.gray("[vite-ssg]")} ${chalk.yellow(text)}${count ? chalk.blue(` (${count})`) : ""}`);
}
function getSize(str) {
  return `${(str.length / 1024).toFixed(2)} KiB`;
}
function routesToPaths(routes) {
  if (!routes)
    return ["/"];
  const paths = new Set();
  const getPaths = (routes2, prefix = "") => {
    prefix = prefix.replace(/\/$/g, "");
    for (const route of routes2) {
      let path = route.path;
      if (route.path) {
        path = prefix && !route.path.startsWith("/") ? `${prefix}/${route.path}` : route.path;
        paths.add(path);
      }
      if (Array.isArray(route.children))
        getPaths(route.children, path);
    }
  };
  getPaths(routes);
  return [...paths];
}

// src/node/critical.ts
function getCritters(outDir, options = {}) {
  try {
    const CrittersClass = __require("critters");
    return new CrittersClass(__spreadValues({
      path: outDir,
      logLevel: "warn",
      external: true,
      inlineFonts: true,
      preloadFonts: true
    }, options));
  } catch (e) {
    return void 0;
  }
}

// src/node/build.ts
function DefaultIncludedRoutes(paths) {
  return paths.filter((i) => !i.includes(":") && !i.includes("*"));
}
function readJson(path) {
  return JSON.parse(fs.readFileSync(path, "utf8"));
}
async function build(cliOptions = {}) {
  var _a;
  const mode = process.env.MODE || process.env.NODE_ENV || cliOptions.mode || "production";
  const config = await resolveConfig({}, "build", mode);
  const cwd = process.cwd();
  const root = config.root || cwd;
  const ssgOut = join(root, ".vite-ssg-temp");
  const outDir = config.build.outDir || "dist";
  const out = isAbsolute(outDir) ? outDir : join(root, outDir);
  const isTypeModule = readJson(resolve(cwd, "package.json")).type === "module";
  const {
    script = "sync",
    mock = false,
    entry = await detectEntry(root),
    formatting = "none",
    crittersOptions = {},
    includedRoutes = DefaultIncludedRoutes,
    onBeforePageRender,
    onPageRendered,
    onFinished,
    dirStyle = "flat",
    includeAllRoutes = false
  } = Object.assign({}, config.ssgOptions || {}, cliOptions);
  if (fs.existsSync(ssgOut))
    await fs.remove(ssgOut);
  buildLog("Build for client...");
  await viteBuild({
    build: {
      ssrManifest: true,
      rollupOptions: {
        input: {
          app: join(root, "./index.html")
        }
      }
    },
    mode: config.mode
  });
  buildLog("Build for server...");
  process.env.VITE_SSG = "true";
  const ssrEntry = await resolveAlias(config, entry);
  await viteBuild({
    build: {
      ssr: ssrEntry,
      outDir: ssgOut,
      minify: false,
      cssCodeSplit: false,
      rollupOptions: {
        output: {
          entryFileNames: `[name].${isTypeModule ? "cjs" : "js"}`
        }
      }
    },
    mode: config.mode
  });
  const { createApp } = __require(join(ssgOut, `${parse(ssrEntry).name}.${isTypeModule ? "cjs" : "js"}`));
  const { routes } = await createApp(false);
  let routesPaths = includeAllRoutes ? routesToPaths(routes) : await includedRoutes(routesToPaths(routes));
  routesPaths = Array.from(new Set(routesPaths));
  buildLog("Rendering Pages...", routesPaths.length);
  const critters = crittersOptions !== false ? getCritters(outDir, crittersOptions) : void 0;
  if (critters)
    console.log(`${chalk2.gray("[vite-ssg]")} ${chalk2.blue("Critical CSS generation enabled via `critters`")}`);
  if (mock) {
    const virtualConsole = new VirtualConsole();
    const jsdom = new JSDOM("", { url: "http://localhost", virtualConsole });
    global.window = jsdom.window;
    Object.assign(global, jsdom.window);
  }
  const ssrManifest = JSON.parse(await fs.readFile(join(out, "ssr-manifest.json"), "utf-8"));
  let indexHTML = await fs.readFile(join(out, "index.html"), "utf-8");
  indexHTML = rewriteScripts(indexHTML, script);
  await Promise.all(routesPaths.map(async (route) => {
    try {
      const { app, router, head, initialState } = await createApp(false, route);
      if (router) {
        await router.push(route);
        await router.isReady();
      }
      const transformedIndexHTML = await (onBeforePageRender == null ? void 0 : onBeforePageRender(route, indexHTML)) || indexHTML;
      const ctx = {};
      const appHTML = await renderToString(app, ctx);
      const renderedHTML = renderHTML({ indexHTML: transformedIndexHTML, appHTML, initialState });
      const jsdom = new JSDOM(renderedHTML);
      renderPreloadLinks(jsdom.window.document, ctx.modules || new Set(), ssrManifest);
      head == null ? void 0 : head.updateDOM(jsdom.window.document);
      const html = jsdom.serialize();
      let transformed = await (onPageRendered == null ? void 0 : onPageRendered(route, html)) || html;
      if (critters)
        transformed = await critters.process(transformed);
      const formatted = format(transformed, formatting);
      const relativeRouteFile = `${(route.endsWith("/") ? `${route}index` : route).replace(/^\//g, "")}.html`;
      const filename = dirStyle === "nested" ? join(route.replace(/^\//g, ""), "index.html") : relativeRouteFile;
      await fs.ensureDir(join(out, dirname(filename)));
      await fs.writeFile(join(out, filename), formatted, "utf-8");
      config.logger.info(`${chalk2.dim(`${outDir}/`)}${chalk2.cyan(filename.padEnd(15, " "))}  ${chalk2.dim(getSize(formatted))}`);
    } catch (err) {
      throw new Error(`${chalk2.gray("[vite-ssg]")} ${chalk2.red(`Error on page: ${chalk2.cyan(route)}`)}
${err.stack}`);
    }
  }));
  await fs.remove(ssgOut);
  const pwaPlugin = (_a = config.plugins.find((i) => i.name === "vite-plugin-pwa")) == null ? void 0 : _a.api;
  if (pwaPlugin == null ? void 0 : pwaPlugin.generateSW) {
    buildLog("Regenerate PWA...");
    await pwaPlugin.generateSW();
  }
  console.log(`
${chalk2.gray("[vite-ssg]")} ${chalk2.green("Build finished.")}`);
  await (onFinished == null ? void 0 : onFinished());
  const waitInSeconds = 15;
  const timeout = setTimeout(() => {
    console.log(`${chalk2.gray("[vite-ssg]")} ${chalk2.yellow(`Build process still running after ${waitInSeconds}s. There might be something misconfigured in your setup. Force exit.`)}`);
    process.exit(0);
  }, waitInSeconds * 1e3);
  timeout.unref();
}
function rewriteScripts(indexHTML, mode) {
  if (!mode || mode === "sync")
    return indexHTML;
  return indexHTML.replace(/<script type="module" /g, `<script type="module" ${mode} `);
}
function renderHTML({ indexHTML, appHTML, initialState }) {
  const stateScript = initialState ? `
<script>window.__INITIAL_STATE__=${initialState}<\/script>` : "";
  return indexHTML.replace('<div id="app"></div>', `<div id="app" data-server-rendered="true">${appHTML}</div>${stateScript}`);
}
function format(html, formatting) {
  if (formatting === "minify") {
    return __require("html-minifier").minify(html, {
      collapseWhitespace: true,
      caseSensitive: true,
      collapseInlineTagWhitespace: false,
      minifyJS: true,
      minifyCSS: true
    });
  } else if (formatting === "prettify") {
    return __require("prettier").format(html, { semi: false, parser: "html" });
  }
  return html;
}
async function detectEntry(root) {
  const scriptSrcReg = /<script(?:.*?)src=["'](.+?)["'](?!<)(?:.*)\>(?:[\n\r\s]*?)(?:<\/script>)/img;
  const html = await fs.readFile(join(root, "index.html"), "utf-8");
  const scripts = [...html.matchAll(scriptSrcReg)];
  const [, entry] = scripts.find((matchResult) => {
    const [script] = matchResult;
    const [, scriptType] = script.match(/.*\stype=(?:'|")?([^>'"\s]+)/i) || [];
    return scriptType === "module";
  }) || [];
  return entry || "src/main.ts";
}
async function resolveAlias(config, entry) {
  const resolver = config.createResolver();
  const result = await resolver(entry, config.root);
  return result || join(config.root, entry);
}

// src/node/cli.ts
yargs.scriptName("vite-ssg").usage("$0 [args]").command("build", "Build SSG", (args) => args.option("script", {
  choices: ["sync", "async", "defer", "async defer"],
  describe: "Rewrites script loading timing"
}).option("mock", {
  type: "boolean",
  describe: "Mock browser globals (window, document, etc.) for SSG"
}), async (args) => {
  await build(args);
}).showHelpOnFail(false).help().argv;
